//typedef
typedef double real_T;
typedef double time_T;
typedef unsigned char boolean_T;
typedef int int_T;
typedef unsigned int uint_T;
typedef unsigned long ulong_T;
typedef char char_T;
typedef unsigned char uchar_T;
typedef char_T byte_T;


//third library : rtwtypes.h

#ifndef RTWTYPES_H
#define RTWTYPES_H

/* Logical type definitions */
#if (!defined(__cplusplus))
#  ifndef false
#   define false                       (0U)
#  endif

#  ifndef true
#   define true                        (1U)
#  endif
#endif

/*=======================================================================*
 * Target hardware information
 *   Device type: Atmel->AVR
 *   Number of bits:     char:   8    short:   16    int:  16
 *                       long:  32    long long:  64
 *                       native word size:   8
 *   Byte ordering: LittleEndian
 *   Signed integer division rounds to: Zero
 *   Shift right on a signed integer as arithmetic shift: on
 *=======================================================================*/

/*=======================================================================*
 * Fixed width word size data types:                                     *
 *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *
 *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *
 *=======================================================================*/
typedef signed char int8_T;
typedef unsigned char uint8_T;
typedef int int16_T;
typedef unsigned int uint16_T;
typedef long int32_T;
typedef unsigned long uint32_T;
typedef long long int64_T;
typedef unsigned long long uint64_T;

/*===========================================================================*
 * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *
 *                           ulong_T, ulonglong_T.                           *
 *===========================================================================*/
typedef unsigned char boolean_T;
typedef int int_T;
typedef unsigned int uint_T;
typedef unsigned long ulong_T;
typedef unsigned long long ulonglong_T;
typedef char char_T;
typedef unsigned char uchar_T;
typedef char_T byte_T;

/*=======================================================================*
 * Min and Max:                                                          *
 *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *
 *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *
 *=======================================================================*/
#define MAX_int8_T                     ((int8_T)(127))
#define MIN_int8_T                     ((int8_T)(-128))
#define MAX_uint8_T                    ((uint8_T)(255U))
#define MAX_int16_T                    ((int16_T)(32767))
#define MIN_int16_T                    ((int16_T)(-32768))
#define MAX_uint16_T                   ((uint16_T)(65535U))
#define MAX_int32_T                    ((int32_T)(2147483647L))
#define MIN_int32_T                    ((int32_T)(-2147483647L-1L))
#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFUL))
#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))
#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))
#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))

/* Block D-Work pointer type */
typedef void * pointer_T;

#endif                                 /* RTWTYPES_H */

//fourth library
#include <stddef.h>
//fifth library : rtmodel.h
#ifndef RTW_HEADER_rtmodel_h_
#define RTW_HEADER_rtmodel_h_
/* Macros generated for backwards compatibility  */
#ifndef rtmGetStopRequested
# define rtmGetStopRequested(rtm)      ((void*) 0)
#endif
#endif   
/////////////////////////////////STEP AND INIT////////////////////////////////////////////////


//code.h generated by matlab
#ifndef RTW_HEADER_btns_h_
#define RTW_HEADER_btns_h_
#include <stddef.h>
#ifndef btns_COMMON_INCLUDES_
# define btns_COMMON_INCLUDES_
#endif                                 /* btns_COMMON_INCLUDES_ */

/* Macros for accessing real-time model data structure */
#ifndef rtmGetErrorStatus
# define rtmGetErrorStatus(rtm)        ((rtm)->errorStatus)
#endif

#ifndef rtmSetErrorStatus
# define rtmSetErrorStatus(rtm, val)   ((rtm)->errorStatus = (val))
#endif

#define btns_M                         (rtM)

/* Forward declaration for rtModel */
typedef struct tag_RTM RT_MODEL;

/* Block signals and states (default storage) for system '<Root>' */
typedef struct {
  uint8_T is_active_c3_btns;           /* '<Root>/Chart' */
  uint8_T is_c3_btns;                  /* '<Root>/Chart' */
  uint8_T temporalCounter_i1;          /* '<Root>/Chart' */
} DW;

/* External inputs (root inport signals with default storage) */
typedef struct {
  real_T Inport;                       /* '<Root>/Inport' */
  real_T Inport1;                      /* '<Root>/Inport1' */
  real_T Inport2;                      /* '<Root>/Inport2' */
  real_T Inport3;                      /* '<Root>/Inport3' */
  real_T Inport4;                      /* '<Root>/Inport4' */
  real_T Inport5;                      /* '<Root>/Inport5' */
} ExtU;

/* Real-time Model Data Structure */
struct tag_RTM {
  const char_T *errorStatus;
};

/* Block signals and states (default storage) */
extern DW rtDW;

/* External inputs (root inport signals with default storage) */
extern ExtU rtU;

/* Model entry point functions */
extern void btns_initialize(void);
extern void btns_step(void);

/* Real-time Model object */
extern RT_MODEL *const rtM;

/*-
 * The generated code includes comments that allow you to trace directly
 * back to the appropriate location in the model.  The basic format
 * is <system>/block_name, where system is the system number (uniquely
 * assigned by Simulink) and block_name is the name of the block.
 *
 * Use the MATLAB hilite_system command to trace the generated code back
 * to the model.  For example,
 *
 * hilite_system('<S3>')    - opens system 3
 * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3
 *
 * Here is the system hierarchy for this model
 *
 * '<Root>' : 'btns'
 * '<S1>'   : 'btns/Chart'
 */
#endif                                 /* RTW_HEADER_btns_h_ */

/*
 * File trailer for generated code.
 *
 * [EOF]
 */


//code.c generated by matlab

/* Named constants for Chart: '<Root>/Chart' */
#define IN_Reset                       ((uint8_T)1U)
#define IN_door_bounce                 ((uint8_T)2U)
#define IN_door_status                 ((uint8_T)3U)
#define IN_floor_bounce                ((uint8_T)4U)
#define IN_floor_pos                   ((uint8_T)5U)
#define IN_one_bounce                  ((uint8_T)6U)
#define IN_one_press                   ((uint8_T)7U)
#define IN_stop_bounce                 ((uint8_T)8U)
#define IN_stop_press                  ((uint8_T)9U)
#define IN_three_bounce                ((uint8_T)10U)
#define IN_three_press                 ((uint8_T)11U)
#define IN_two_bounce                  ((uint8_T)12U)
#define IN_two_press                   ((uint8_T)13U)

/* Block signals and states (default storage) */
DW rtDW;

/* External inputs (root inport signals with default storage) */
ExtU rtU;

/* Real-time model */
RT_MODEL rtM_;
RT_MODEL *const rtM = &rtM_;

/* Model step function */
void btns_step(void)
{
  /* Chart: '<Root>/Chart' incorporates:
   *  Inport: '<Root>/Inport'
   *  Inport: '<Root>/Inport1'
   *  Inport: '<Root>/Inport2'
   *  Inport: '<Root>/Inport3'
   *  Inport: '<Root>/Inport4'
   *  Inport: '<Root>/Inport5'
   */
  if (rtDW.temporalCounter_i1 < 3U) {
    rtDW.temporalCounter_i1++;
  }

  if (rtDW.is_active_c3_btns == 0U) {
    rtDW.is_active_c3_btns = 1U;
    rtDW.is_c3_btns = IN_Reset;
  } else {
    switch (rtDW.is_c3_btns) {
     case IN_Reset:
      if (rtU.Inport1 == 1.0) {
        rtDW.is_c3_btns = IN_two_bounce;
        rtDW.temporalCounter_i1 = 0U;
      } else if (rtU.Inport2 == 1.0) {
        rtDW.is_c3_btns = IN_three_bounce;
        rtDW.temporalCounter_i1 = 0U;
      } else if (rtU.Inport4 == 1.0) {
        rtDW.is_c3_btns = IN_door_bounce;
        rtDW.temporalCounter_i1 = 0U;
      } else if (rtU.Inport3 == 1.0) {
        rtDW.is_c3_btns = IN_stop_bounce;
        rtDW.temporalCounter_i1 = 0U;
      } else if (rtU.Inport == 1.0) {
        rtDW.is_c3_btns = IN_one_bounce;
        rtDW.temporalCounter_i1 = 0U;
      } else {
        if (rtU.Inport5 == 1.0) {
          rtDW.is_c3_btns = IN_floor_bounce;
          rtDW.temporalCounter_i1 = 0U;
        }
      }
      break;

     case IN_door_bounce:
      if ((rtU.Inport4 == 1.0) && (rtDW.temporalCounter_i1 >= 1U)) {
        rtDW.is_c3_btns = IN_door_status;
      } else {
        if (rtU.Inport4 == 0.0) {
          rtDW.is_c3_btns = IN_Reset;
        }
      }
      break;

     case IN_door_status:
      rtDW.is_c3_btns = IN_Reset;
      break;

     case IN_floor_bounce:
      if (rtU.Inport5 == 0.0) {
        rtDW.is_c3_btns = IN_Reset;
      } else {
        if ((rtU.Inport5 == 1.0) && (rtDW.temporalCounter_i1 >= 1U)) {
          rtDW.is_c3_btns = IN_floor_pos;
        }
      }
      break;

     case IN_floor_pos:
      rtDW.is_c3_btns = IN_Reset;
      break;

     case IN_one_bounce:
      if ((rtU.Inport == 1.0) && (rtDW.temporalCounter_i1 >= 1U)) {
        rtDW.is_c3_btns = IN_one_press;
      } else {
        if (rtU.Inport == 0.0) {
          rtDW.is_c3_btns = IN_Reset;
        }
      }
      break;

     case IN_one_press:
      rtDW.is_c3_btns = IN_Reset;
      break;

     case IN_stop_bounce:
      if ((rtU.Inport3 == 1.0) && (rtDW.temporalCounter_i1 >= 1U)) {
        rtDW.is_c3_btns = IN_stop_press;
      } else {
        if (rtU.Inport3 == 0.0) {
          rtDW.is_c3_btns = IN_Reset;
        }
      }
      break;

     case IN_stop_press:
      rtDW.is_c3_btns = IN_Reset;
      break;

     case IN_three_bounce:
      if ((rtU.Inport2 == 1.0) && (rtDW.temporalCounter_i1 >= 1U)) {
        rtDW.is_c3_btns = IN_three_press;
      } else {
        if (rtU.Inport2 == 0.0) {
          rtDW.is_c3_btns = IN_Reset;
        }
      }
      break;

     case IN_three_press:
      rtDW.is_c3_btns = IN_Reset;
      break;

     case IN_two_bounce:
      if ((rtU.Inport1 == 1.0) && (rtDW.temporalCounter_i1 >= 1U)) {
        rtDW.is_c3_btns = IN_two_press;
      } else {
        if (rtU.Inport1 == 0.0) {
          rtDW.is_c3_btns = IN_Reset;
        }
      }
      break;

     default:
      rtDW.is_c3_btns = IN_Reset;
      break;
    }
  }

  /* End of Chart: '<Root>/Chart' */
}

/* Model initialize function */
void btns_initialize(void)
{
  /* (no initialization code required) */
}

/*
 * File trailer for generated code.
 *
 * [EOF]
 */





void setup(){

}
void loop(){

}